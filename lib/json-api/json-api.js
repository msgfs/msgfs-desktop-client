const fs = require('fs');
const sha512 = require('js-sha512').sha512;
const electron = require('electron');
const path = require('path');
const app = electron.app;
const log = require('electron-log');

const getKeyList = (callback) => {
	const data = JSON.stringify({
	  list_known_owners: true
	});
	return runRequest(data, callback);
}

const newIdentity = (callback) => {
	const data = JSON.stringify({
		generate_new_key: true
	});
	return runRequest(data, callback)
}

const connectIdentity = (id, callback) => {
	const data = JSON.stringify({
		connect_identity: true,
		identity: id
	});

	log.info("connecting identity", id)
	return runRequest(data, callback, true);
}

const importIdentityInvite = (id, text, callback) => {
	const filePath = getTempFilePath(`${uuid4()}.incoming.bin`);
	let inviteBuffer = Buffer.from(text, 'base64');
	fs.writeFileSync(filePath, inviteBuffer);
	log.info("save identity into", filePath)
	const data = JSON.stringify({
		identity: id,
		import_identity_path: filePath,
	});
	return runRequest(data, callback, true);
}


const tmp = app.getPath("temp")
const getTempFilePath = (filename) => { return path.join(tmp, filename) }

// generated by GPT-6-J with:
// short javascript function to generate uuid v4:
function uuid4() {
	let d = new Date().getTime();
	const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
		const r = (d + Math.random() * 16) % 16 | 0;
		d = Math.floor(d / 16);
		return (c === 'x' ? r : (r & 0x7f | 0x3f)).toString(16);
	});
	return uuid;
}

const uploadFile = (id, path, share, callback) => {
	const data = JSON.stringify({
		file_path_to_upload: path,
		share_with_owners: share || [],
		identity: id
	});
	log.info("upload file", id, path)
	return runRequest(data, callback, true);
}


const downloadFile = (id, index, path, callback) => {
	const data = JSON.stringify({
		download_path: path,
		file_to_download: index,
		identity: id
	});
	log.info("set download file", id, index, path)
	return runRequest(data, callback, true);
}

const setDownloadPath = (id, path, callback) => {
	const data = JSON.stringify({
		download_path: path,
		identity: id
	});
	log.info("set download path", id, path)
	return runRequest(data, callback, true);
}

const createOwnInvite = (id, callback) => {
	const temporaryPath = getTempFilePath(`invite-${uuid4()}.bin`)
	const data = JSON.stringify({
		generate_invite_to_path: temporaryPath,
		identity: id
	});

	return runRequest(data, (resp) => {
		callback(temporaryPath, resp);
	});
}

const http = require('http');

const runRequest = (data, callback, vb) => {
	if (vb) { log.info("request", data) } else { log.debug("request", data) }
	const options = {
	  hostname: '127.0.0.1',
	  port: 8080,
	  path: '/',
	  method: 'POST',
	  headers: {
	    'Content-Type': 'application/json',
	    'Content-Length': data.length
	  }
	};

	const req = http.request(options, res => {
	  res.on('data', d => {
	  	try {
	  		const parsed = JSON.parse(d)
			if (parsed.ok === true) {
				if (vb) { log.info("response", parsed) } else { log.debug("response", JSON.stringify(parsed, null, 4)) }
				callback(parsed);
			} else {
				log.error("got error response: ", parsed);
			}
	  	} catch (e) {
	  		log.error("got error reading response: ", e);
	  	}
	  })
	});

	req.on('error', error => {
	  log.error("got error getting key list: ", error)
	});

	req.write(data);
	req.end();
}


exports.getKeyList = getKeyList;
exports.connectIdentity = connectIdentity;
exports.uuid4 = uuid4;
exports.createOwnInvite = createOwnInvite;
exports.importIdentityInvite = importIdentityInvite;
exports.newIdentity = newIdentity
exports.uploadFile = uploadFile;
exports.downloadFile = downloadFile
exports.setDownloadPath = setDownloadPath